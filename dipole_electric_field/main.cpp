#include "vector_field.h"
#include "material_point.h"
#include "TApplication.h"
#include "TGraph.h"
#include "TCanvas.h"
#include "TAxis.h"
#include "TArrow.h"
#include "TPaveLabel.h"


int main(int argc, char** argv){
    if (argc!= 4) {
        cerr << "Usage "<< argv[0] << " <x> <y> <z> " << endl;
        return 1;
    }
    
    double m_proton = 1.67262192369 *pow(10,-27);
    double m_electron = 9.1093837015 *pow(10,-31);
    double q_electron = -1.602176634*pow(10,-19);
   
    position myposition (atof(argv[1]),atof(argv[2]),atof(argv[3]) ); 
    double charge_distance = 1*pow(10,-10); 
    
    

    material_point e (m_electron, q_electron,0.,0.,charge_distance/2.);
    material_point p (m_proton, -q_electron ,0.,0.,-charge_distance/2.);
    
    vector_field E = e.electric_field(myposition) + p.electric_field(myposition); 
   
    cout << "Campo Elettrico (" << E.GetFx() << ", " << E.GetFy() << ", " << E.GetFz() << ") " << endl;
    cout << "Il module del campo elettrico nel punto indicato Ã¨ " << E.module()<< " V/m"<< endl;

    //==========================================
    //          trend on z
    //==========================================

    TApplication app ("app", 0, 0);
    TCanvas c1( "E" , "Andamento di E", 600, 400 );
    TGraph h;
    position x(0,0, 100*charge_distance);
    int i = 0;
    double temp = 0.;
    while (x.GetZ() <= 1000*charge_distance ){
        E = e.electric_field(x) + p.electric_field(x);
        temp = E.module();
        h.SetPoint(i, x.GetZ(), temp);
        x.SetZ( 1.1 * x.GetZ() );
        i++;
    }
    c1.cd();
    h.SetTitle("Andamento del campo generato dal dipolo");
    h.GetXaxis()->SetTitle("delta [m]");
    h.GetYaxis()->SetTitle("E [V/m]");
    h.SetLineWidth(3);
    h.Draw();
    
    //==========================================
    //  find the trend of the field
    //==========================================


    double E1, E2, R1, R2;
    h.GetPoint(0, R1, E1);
    h.GetPoint(10, R2, E2);
    int alpha = log(E1/E2)/log(R1/R2);
    cout << "trend of the field: E = kR^" << alpha << endl;
    
    
    //==========================================
    //          field behaviour
    //==========================================

    TCanvas c2( "E" , "Dipole electric field", 900, 600 );
    c1.DrawFrame(-15*charge_distance, -15*charge_distance, 15*charge_distance, 15*charge_distance, "Field generated by two charges; y[m];z[m]");
    
    position k(0,0, -15*charge_distance);
    
    
    while (k.GetZ() <= 15*charge_distance){
        k.SetY(-15*charge_distance); 
        while(k.GetY() <= 15*charge_distance ){
            E = e.electric_field(k) + p.electric_field(k);
            double scale = 10E-22;
            
            if( k.GetY()<2.5E-10 && k.GetY()>-2.5E-10  && k.GetZ()<2.5E-10  && k.GetZ()>-2.5E-10 ) {
                k.SetY(k.GetY()+charge_distance); 
                continue;
            }
            else{
                k.SetY(k.GetY()+charge_distance); 
                TArrow *field = new
                TArrow(k.GetY(), k.GetZ(), k.GetY()+E.GetFy()*scale, k.GetZ()+E.GetFz()*scale, 0.01 ,">");
                field->Draw(">");
                if (E.module()>1E9){ field->SetLineColor(kRed+1); field->SetLineWidth(4);}
                else if (E.module()<1E9 && E.module()>1E8){ field->SetLineColor(kOrange+6); field->SetLineWidth(4);}
                else if (E.module()<1E8){ field->SetLineColor(kOrange+0); field->SetLineWidth(4);}

            }
        }
        k.SetZ(k.GetZ()+charge_distance );
    }

    c1.cd();
    h.SetTitle("Dipole electric field");
    h.GetXaxis()->SetTitle("delta [m]");
    h.GetYaxis()->SetTitle("E [V/m]");
    h.SetLineWidth(3);
    h.Draw();
    app.Run();
    return 0;
}
